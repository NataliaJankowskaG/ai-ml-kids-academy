# pages/04_Que_es_Regresion_Lineal.py

import streamlit as st
import matplotlib.pyplot as plt
import numpy as np
import os
import json
from streamlit_lottie import st_lottie
from openai import OpenAI
from gtts import gTTS
import io
import random
import time
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

st.set_page_config(
    page_title="¬øQu√© es la Regresi√≥n Lineal?",
    layout="wide"
)

# ---- Funci√≥n para cargar animaci√≥n Lottie desde un archivo local ----
def load_lottiefile(filepath: str):
    try:
        with open(filepath, "r") as f:
            return json.load(f)
    except FileNotFoundError:
        st.error(f"Error: No se encontr√≥ el archivo Lottie en la ruta: {filepath}")
        return None
    except json.JSONDecodeError:
        st.error(f"Error: El archivo Lottie '{filepath}' no es un JSON v√°lido.")
        return None
    except Exception as e:
        st.error(f"Error inesperado al cargar el archivo Lottie '{filepath}': {e}. Aseg√∫rate de que el archivo no est√© corrupto y sea un JSON v√°lido.")
        return None

# --- Rutas a Lottie ---
LOTTIE_PREDICT_PATH = os.path.join("assets", "lottie_animations", "Math.json")


# --- Configuraci√≥n de la API de OpenAI ---
try:
    openai_api_key = st.secrets["OPENAI_API_KEY"]
except KeyError:
    openai_api_key = None
    st.error("Error: La clave de API de OpenAI no est√° configurada en `secrets.toml`.")
    st.info("Para configurarla, crea un archivo `.streamlit/secrets.toml` en la ra√≠z de tu proyecto y a√±ade: `OPENAI_API_KEY = 'tu_clave_aqui'`")

client = OpenAI(api_key=openai_api_key) if openai_api_key else None


st.subheader("¬°Adivina el futuro con matem√°ticas simples!")

st.write("---")

# Secci√≥n 1: ¬øQu√© es la Regresi√≥n Lineal?
st.header("¬øQu√© es la Regresi√≥n Lineal?")
st.markdown("""
Imagina que quieres saber cu√°nto crecer√° una planta la pr√≥xima semana,
o cu√°ntos helados se vender√°n si hace mucho calor.

La **Regresi√≥n Lineal** es como tener una bola de cristal matem√°tica.
Nos ayuda a **predecir un n√∫mero** bas√°ndonos en otros n√∫meros que ya conocemos.
¬°Es como encontrar la "l√≠nea m√°gica" que conecta los puntos de nuestros datos!
""")

# Peque√±a animaci√≥n para la introducci√≥n
col_intro_left, col_intro_right = st.columns([1, 1])
with col_intro_right:
    lottie_predict = load_lottiefile(LOTTIE_PREDICT_PATH)
    if lottie_predict:
        st_lottie(lottie_predict, height=200, width=200, key="predict_intro")
    else:
        st.info("Consejo: Aseg√∫rate de que 'Math.json' (o una mejor) est√© en 'assets/lottie_animations/' para esta animaci√≥n.")

st.write("---")

# Secci√≥n 2: ¬øC√≥mo Predice la Regresi√≥n Lineal? (Visualizaci√≥n Interactiva)
st.header("¬øC√≥mo Predice la Regresi√≥n Lineal?")
st.markdown("""
Las m√°quinas usan la regresi√≥n lineal para encontrar una l√≠nea recta que se ajuste lo mejor posible a los puntos de datos.
¬°As√≠ pueden hacer predicciones!

**¬°Vamos a simular c√≥mo una IA predice el tama√±o de un zapato en funci√≥n de la altura!**
""")

st.subheader("Predicci√≥n del Tama√±o del Zapato: ¬°Ayuda a la IA a dibujar la l√≠nea!")

st.markdown("""
Puedes a√±adir "ejemplos" (puntos) haciendo clic en el gr√°fico. La IA intentar√° dibujar una l√≠nea
que se ajuste a tus puntos y as√≠ har√° predicciones.
""")

# Inicializar juego en session_state
if 'shoe_data' not in st.session_state:
    st.session_state.shoe_data = [] # Lista de diccionarios: [{'height': x, 'shoe_size': y}]

# Crear el gr√°fico
fig_reg, ax_reg = plt.subplots(figsize=(9, 7))
ax_reg.set_xlabel("Altura (cm)")
ax_reg.set_ylabel("Talla de Zapato")
ax_reg.set_title("Predicci√≥n de Talla de Zapato vs. Altura")
ax_reg.set_xlim(100, 200) # Altura t√≠pica
ax_reg.set_ylim(20, 50) # Talla de zapato t√≠pica
ax_reg.grid(True, linestyle='--', alpha=0.6)

if not st.session_state.shoe_data:
    ax_reg.text((ax_reg.get_xlim()[0] + ax_reg.get_xlim()[1]) / 2,
                (ax_reg.get_ylim()[0] + ax_reg.get_ylim()[1]) / 2,
                "¬°Haz clic en el gr√°fico para a√±adir puntos!",
                horizontalalignment='center', verticalalignment='center',
                fontsize=14, color='gray', alpha=0.6)

# Convertir los datos a numpy arrays para el modelo
X_reg_data = np.array([d['height'] for d in st.session_state.shoe_data]).reshape(-1, 1)
y_reg_data = np.array([d['shoe_size'] for d in st.session_state.shoe_data])

# Plotear los puntos existentes
if len(st.session_state.shoe_data) > 0:
    ax_reg.scatter(X_reg_data, y_reg_data, color='blue', s=100, label='Ejemplos (Talla de Zapato)', zorder=3)
    ax_reg.legend()

model_reg = None
# Entrenar el modelo de regresi√≥n lineal si hay suficientes puntos (al menos 2)
if len(st.session_state.shoe_data) >= 2:
    model_reg = LinearRegression()
    model_reg.fit(X_reg_data, y_reg_data)

    # Dibujar la l√≠nea de regresi√≥n
    x_line = np.array([ax_reg.get_xlim()[0], ax_reg.get_xlim()[1]]).reshape(-1, 1)
    y_line = model_reg.predict(x_line)
    ax_reg.plot(x_line, y_line, color='red', linestyle='--', linewidth=2, label='L√≠nea de Predicci√≥n de la IA', zorder=2)
    ax_reg.legend()

    # Evaluar el modelo
    y_pred = model_reg.predict(X_reg_data)
    mse = mean_squared_error(y_reg_data, y_pred)
    r2 = r2_score(y_reg_data, y_pred)
    st.markdown(f"**La l√≠nea de la IA:** Cuanto mejor se ajusta a los puntos, mejor puede predecir.")

# Mostrar el gr√°fico
clicked_point = st.pyplot(fig_reg, use_container_width=True)


st.markdown("---")
st.subheader("¬°A√±ade tus propios puntos de datos y ve la l√≠nea m√°gica!")

col_add_point1, col_add_point2, col_add_point3 = st.columns(3)

with col_add_point1:
    user_height = st.slider("Altura (cm):", min_value=100.0, max_value=200.0, value=150.0, step=1.0, key="user_height_reg")
with col_add_point2:
    user_shoe_size = st.slider("Talla de Zapato:", min_value=20.0, max_value=50.0, value=35.0, step=0.5, key="user_shoe_size_reg")
with col_add_point3:
    st.markdown(" ")
    st.markdown(" ")
    add_point_button = st.button("A√±adir este punto al gr√°fico", key="add_reg_point")
    if add_point_button:
        st.session_state.shoe_data.append({'height': user_height, 'shoe_size': user_shoe_size})
        st.rerun()

if st.button("Borrar todos los puntos", key="clear_reg_points"):
    st.session_state.shoe_data = []
    st.rerun()

if model_reg is not None:
    st.markdown("---")
    st.subheader("¬°Haz una predicci√≥n con la l√≠nea de la IA!")
    predict_height = st.slider("¬øPara qu√© altura quieres predecir la talla de zapato?", min_value=100.0, max_value=200.0, value=170.0, step=1.0, key="predict_height_slider")
    predicted_shoe_size = model_reg.predict(np.array([[predict_height]]))[0]
    st.markdown(f"Si la altura es **{predict_height:.0f} cm**, la IA predice que la talla de zapato ser√° **{predicted_shoe_size:.1f}**.")
    ax_reg.plot(predict_height, predicted_shoe_size, 'o', color='purple', markersize=12, label='Predicci√≥n de IA üîÆ', zorder=4)
    ax_reg.legend()
    st.pyplot(fig_reg) # Volver a mostrar el gr√°fico con la predicci√≥n


st.markdown("""
¬øVes c√≥mo la l√≠nea roja se mueve cuando a√±ades m√°s puntos? La IA intenta encontrar la mejor l√≠nea recta
que pase por el medio de todos los puntos. Una vez que tiene esa l√≠nea, puede **predecir**
nuevos valores, ¬°incluso para alturas que no le has dado antes!

Esto es √∫til para predecir precios de casas, ventas de productos, ¬°o incluso el clima!
""")

st.write("---")

# --- Secci√≥n de Chatbot de Juego con L√≠neo para "Qu√© es la Regresi√≥n Lineal" ---
st.header("¬°Juega y Aprende con L√≠neo sobre la Regresi√≥n Lineal!")
st.markdown("¬°Hola! Soy L√≠neo, tu compa√±ero que dibuja el futuro. ¬øListo para descubrir c√≥mo las m√°quinas adivinan n√∫meros?")

if client:
    # Inicializa el estado del juego y los mensajes del chat
    if "reg_game_active" not in st.session_state:
        st.session_state.reg_game_active = False
    if "reg_game_messages" not in st.session_state:
        st.session_state.reg_game_messages = []
    if "reg_current_question" not in st.session_state:
        st.session_state.reg_current_question = None
    if "reg_current_options" not in st.session_state:
        st.session_state.reg_current_options = {}
    if "reg_correct_answer" not in st.session_state:
        st.session_state.reg_correct_answer = None
    if "reg_awaiting_next_game_decision" not in st.session_state:
        st.session_state.reg_awaiting_next_game_decision = False
    if "reg_game_needs_new_question" not in st.session_state:
        st.session_state.reg_game_needs_new_question = False
    if "reg_correct_streak" not in st.session_state:
        st.session_state.reg_correct_streak = 0
    if "last_played_question_lineo" not in st.session_state:
        st.session_state.last_played_question_lineo = None


    # System prompt para el juego de preguntas
    reg_game_system_prompt = f"""
    Eres un **experto consumado en Modelado Estad√≠stico y Machine Learning**, con una especializaci√≥n profunda en el **An√°lisis de Regresi√≥n Lineal**. Comprendes a fondo sus fundamentos te√≥ricos, supuestos, aplicaciones pr√°cticas y limitaciones. Tu misi√≥n es actuar como un **tutor interactivo y desafiante**, guiando a los usuarios a trav√©s del dominio de la Regresi√≥n Lineal mediante un **juego de preguntas adaptativo**. Tu lenguaje y la complejidad de las preguntas deben ajustarse rigurosamente al nivel actual del usuario, alcanzando un tono y contenido de **nivel universitario/bootcamp** para los usuarios m√°s avanzados.

    **TU √öNICO TRABAJO es generar preguntas y respuestas en un formato espec√≠fico y estricto, y NADA M√ÅS.**
    **¬°Es CR√çTICO que tus preguntas sean MUY VARIADAS, CREATIVAS Y NO REPETITIVAS! Evita patrones de preguntas obvios o que sigan la misma estructura.**

    **Cuando te pida una pregunta, responde EXCLUSIVAMENTE con el siguiente formato, y NADA M√ÅS:**
    Pregunta: [Tu pregunta aqu√≠]
    A) [Opci√≥n A]
    B) [Opci√≥n B]
    C) [Opci√≥n C]
    RespuestaCorrecta: [A, B o C]

    **Cuando te pida feedback, responde EXCLUSIVAMENTE con el siguiente formato, y NADA M√ÅS:**
    [Mensaje de Correcto/Incorrecto, ej: "¬°Ajuste perfecto! Tu predicci√≥n es precisa." o "Esa estimaci√≥n necesita revisarse. Repasemos los coeficientes."]
    [Breve explicaci√≥n del concepto, adecuada al nivel del usuario, ej: "La Regresi√≥n Lineal es un m√©todo estad√≠stico para modelar la relaci√≥n lineal entre una variable dependiente continua y una o m√°s variables independientes..."]
    [Pregunta para continuar, ej: "¬øListo para optimizar tus modelos de predicci√≥n?" o "¬øQuieres explorar los supuestos cr√≠ticos de la regresi√≥n lineal?"]

    **Reglas adicionales para el Experto en Regresi√≥n Lineal:**
    * **Enfoque Riguroso en Regresi√≥n Lineal:** Todas tus preguntas y explicaciones deben girar en torno a la Regresi√≥n Lineal (simple y m√∫ltiple). Cubre sus fundamentos (ecuaci√≥n, coeficientes, intercepci√≥n), supuestos (linealidad, independencia, homocedasticidad, normalidad de los residuos), interpretaci√≥n de resultados (coeficientes, p-valores, $R^2$), evaluaci√≥n del modelo (RMSE, MAE, $R^2$, $R^2$ ajustado), manejo de outliers y multicolinealidad, y aplicaciones pr√°cticas.
    * **¬°VARIEDAD, VARIEDAD, VARIEDAD!** Aseg√∫rate de que cada pregunta sea diferente en su formulaci√≥n, el ejemplo que utiliza y el concepto espec√≠fico de Regresi√≥n Lineal que eval√∫a. Rota entre los siguientes subtemas, asegurando una cobertura amplia y equilibrada:
        * **Concepto General:** ¬øQu√© es la regresi√≥n lineal? ¬øPara qu√© sirve? (predicci√≥n de valores continuos).
        * **Ecuaci√≥n de Regresi√≥n:** Comprensi√≥n de $y = \beta_0 + \beta_1 x + \epsilon$, qu√© representan $\beta_0$, $\beta_1$, $x$, $y$, y $\epsilon$.
        * **Estimaci√≥n de Par√°metros:** M√≠nimos Cuadrados Ordinarios (OLS) de forma intuitiva.
        * **Supuestos del Modelo:**
            * **Linealidad:** La relaci√≥n entre variables es lineal.
            * **Independencia de Residuos:** No autocorrelaci√≥n.
            * **Homocedasticidad:** Varianza constante de los residuos.
            * **Normalidad de Residuos:** Residuos distribuidos normalmente.
            * **No Multicolinealidad** (para regresi√≥n m√∫ltiple).
        * **Interpretaci√≥n de Coeficientes:** C√≥mo se interpreta $\beta_1$ y $\beta_0$.
        * **Evaluaci√≥n del Modelo:**
            * **M√©tricas:** RMSE, MAE, $R^2$ (coeficiente de determinaci√≥n), $R^2$ ajustado.
            * **Significancia Estad√≠stica:** P-valores, intervalos de confianza.
        * **Diagn√≥stico del Modelo:** An√°lisis de residuos (gr√°ficos de residuos vs. predichos), gr√°ficos Q-Q.
        * **Manejo de Problemas:** Outliers, heterocedasticidad, multicolinealidad (VIF).
        * **Regresi√≥n Lineal M√∫ltiple:** A√±adir m√°s predictores, diferencias con la simple.
        * **Ventajas y Limitaciones:** Simplicidad, interpretabilidad vs. rigidez de supuestos.

    * **Progreso de Dificultad y Tono (Crucial):** El usuario ha respondido {st.session_state.reg_correct_streak} preguntas correctas consecutivas.
        * **Nivel 1 (Aprendiz de Estad√≠stico ‚Äì 0-2 respuestas correctas):** Tono introductorio y conceptual. Preguntas sobre la idea b√°sica de encontrar una l√≠nea para predecir un valor y ejemplos simples de relaciones lineales.
            * *Tono:* "Est√°s trazando tus primeras l√≠neas en el mapa de las predicciones estad√≠sticas."
        * **Nivel 2 (Analista de Regresi√≥n ‚Äì 3-5 respuestas correctas):** Tono m√°s t√©cnico. Introduce la ecuaci√≥n b√°sica, los conceptos de variable dependiente e independiente, y la interpretaci√≥n fundamental de los coeficientes.
            * *Tono:* "Tu an√°lisis de la relaci√≥n entre variables es cada vez m√°s preciso."
        * **Nivel 3 (Modelador de Regresi√≥n ‚Äì 6-8 respuestas correctas):** Tono de **nivel universitario/bootcamp**. Profundiza en los supuestos del modelo, las m√©tricas de evaluaci√≥n ($R^2$, RMSE), la detecci√≥n de problemas (outliers, heterocedasticidad) y la regresi√≥n lineal m√∫ltiple.
            * *Tono:* "Tu habilidad para construir, evaluar y diagnosticar modelos de regresi√≥n lineal es fundamental para el an√°lisis predictivo."
        * **Nivel Maestro (Cient√≠fico de Datos Cuantitativo ‚Äì 9+ respuestas correctas):** Tono de **especialista en modelado estad√≠stico avanzado**. Preguntas sobre la violaci√≥n de supuestos y sus consecuencias, la correcci√≥n de problemas complejos (transformaciones de Box-Cox, weighted least squares), la comparaci√≥n con otros modelos lineales generalizados, o las implicaciones de la multicolinealidad en la inferencia. Se esperan respuestas que demuestren una comprensi√≥n te√≥rica y pr√°ctica robusta.
            * *Tono:* "Tu maestr√≠a en el an√°lisis de regresi√≥n lineal te permite desentra√±ar relaciones complejas y construir modelos predictivos con gran rigor estad√≠stico."
        * Si el usuario responde 3 preguntas bien consecutivas, la dificultad sube GRADUALMENTE.
        * Si falla una pregunta, el contador se resetea a 0 y la dificultad vuelve al Nivel 1.
        * Si subes de nivel, ¬°aseg√∫rate de felicitar al usuario de forma entusiasta y explicando a qu√© tipo de nivel ha llegado!

    * **Ejemplos y Casos de Uso (Adaptados al Nivel):**
        * **Nivel 1:** Predecir el peso de una persona bas√°ndose en su altura.
        * **Nivel 2:** Estimar el precio de una casa en funci√≥n de su tama√±o en metros cuadrados, o la calificaci√≥n de un estudiante seg√∫n las horas de estudio.
        * **Nivel 3:** Modelar el impacto de la inversi√≥n publicitaria y el precio en las ventas de un producto, analizando los residuos para verificar la bondad del ajuste.
        * **Nivel Maestro:** Desarrollar un modelo de regresi√≥n lineal robusto para predecir el rendimiento de cosechas agr√≠colas considerando m√∫ltiples variables clim√°ticas y de suelo, evaluando cuidadosamente la multicolinealidad y la homocedasticidad.

    * **Un Turno a la Vez:** Haz solo una pregunta a la vez y espera la respuesta del usuario antes de hacer la siguiente.
    * **S√© motivador y profesional:** Usa un tono que incite al aprendizaje y al rigor t√©cnico, adaptado al nivel de cada etapa.
    * **Siempre responde en espa√±ol de Espa√±a.**
    * **La pregunta debe ser MUY VARIADA Y CREATIVA** sobre REGRESI√ìN LINEAL, y aseg√∫rate de que no se parezca a las anteriores.
    """

    # Funci√≥n para parsear la respuesta de la IA (extraer pregunta, opciones y respuesta correcta)
    def parse_reg_question_response(raw_text):
        question = ""
        options = {}
        correct_answer_key = ""
        lines = raw_text.split('\n')
        for line in lines:
            line = line.strip()
            if line.lower().startswith("pregunta:"):
                question = line[len("pregunta:"):].strip()
            elif line.lower().startswith("a)"):
                options['A'] = line[len("a):"):].strip()
            elif line.lower().startswith("b)"):
                options['B'] = line[len("b):"):].strip()
            elif line.lower().startswith("c)"):
                options['C'] = line[len("c):"):].strip()
            elif line.lower().startswith("respuestacorrecta:"):
                correct_answer_key = line[len("respuestacorrecta:"):].strip().upper()
        if not (question and len(options) == 3 and correct_answer_key in options):
            st.warning(f"DEBUG: Formato de pregunta inesperado de la API. Texto recibido:\n{raw_text}")
            return None, {}, ""
        return question, options, correct_answer_key

    # Funci√≥n para parsear la respuesta de feedback de la IA
    def parse_reg_feedback_response(raw_text):
        lines = [line.strip() for line in raw_text.split('\n') if line.strip()]
        if len(lines) >= 3:
            return lines[0], lines[1], lines[2]
        st.warning(f"DEBUG: Formato de feedback inesperado de la API. Texto recibido:\n{raw_text}")
        return "Respuesta procesada.", "Aqu√≠ tienes la explicaci√≥n.", "¬øQuieres otra pregunta?"

    # --- Funciones para subir de nivel directamente ---
    def set_lineo_level(target_streak, level_name):
        st.session_state.reg_correct_streak = target_streak
        st.session_state.reg_game_active = True
        st.session_state.reg_game_messages = []
        st.session_state.reg_current_question = None
        st.session_state.reg_current_options = {}
        st.session_state.reg_correct_answer = None
        st.session_state.reg_game_needs_new_question = True
        st.session_state.reg_awaiting_next_game_decision = False
        st.session_state.reg_game_messages.append({"role": "assistant", "content": f"¬°Hola! ¬°Has saltado directamente al **Nivel {level_name}** de L√≠neo! Prep√°rate para preguntas m√°s desafiantes. ¬°Aqu√≠ va tu primera!"})
        st.rerun()

    # Botones para iniciar o reiniciar el juego y subir de nivel
    col_game_buttons_lineo, col_level_up_buttons_lineo = st.columns([1, 2])

    with col_game_buttons_lineo:
        if st.button("¬°Vamos a jugar con L√≠neo!", key="start_lineo_game_button"):
            st.session_state.reg_game_active = True
            st.session_state.reg_game_messages = []
            st.session_state.reg_current_question = None
            st.session_state.reg_current_options = {}
            st.session_state.reg_correct_answer = None
            st.session_state.reg_game_needs_new_question = True
            st.session_state.reg_awaiting_next_game_decision = False
            st.session_state.reg_correct_streak = 0
            st.session_state.last_played_question_lineo = None
            st.rerun()
    
    with col_level_up_buttons_lineo:
        st.markdown("<p style='font-size: 1.1em; font-weight: bold;'>¬øYa eres un experto en l√≠neas? ¬°Salta de nivel! üëá</p>", unsafe_allow_html=True)
        col_lvl1_lineo, col_lvl2_lineo, col_lvl3_lineo = st.columns(3) # Tres columnas para los botones de nivel
        with col_lvl1_lineo:
            if st.button("Subir a Nivel Medio (L√≠neo)", key="level_up_medium_lineo"):
                set_lineo_level(3, "Medio") # 3 respuestas correctas para Nivel Medio
        with col_lvl2_lineo:
            if st.button("Subir a Nivel Avanzado (L√≠neo)", key="level_up_advanced_lineo"):
                set_lineo_level(6, "Avanzado") # 6 respuestas correctas para Nivel Avanzado
        with col_lvl3_lineo:
            if st.button("üëë ¬°Maestro de L√≠neas! (L√≠neo)", key="level_up_champion_lineo"):
                set_lineo_level(9, "Campe√≥n") # 9 respuestas correctas para Nivel Campe√≥n


    # Mostrar mensajes del juego del chatbot
    for message in st.session_state.reg_game_messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])

    # L√≥gica del juego del chatbot si est√° activo
    if st.session_state.reg_game_active:
        if st.session_state.reg_current_question is None and st.session_state.reg_game_needs_new_question and not st.session_state.reg_awaiting_next_game_decision:
            with st.spinner("L√≠neo est√° preparando una pregunta..."):
                try:
                    # Incluimos el prompt del sistema actualizado con el nivel de dificultad
                    game_messages_for_api = [{"role": "system", "content": reg_game_system_prompt}]
                    if st.session_state.reg_game_messages:
                        last_message = st.session_state.reg_game_messages[-1]
                        if last_message["role"] == "user":
                            game_messages_for_api.append({"role": "user", "content": f"MI RESPUESTA: {last_message['content']}"})
                        elif last_message["role"] == "assistant":
                            game_messages_for_api.append({"role": "assistant", "content": last_message['content']})

                    game_messages_for_api.append({"role": "user", "content": "Genera una **nueva pregunta** sobre QU√â ES LA REGRESI√ìN LINEAL siguiendo el formato exacto. ¬°Recuerda, la pregunta debe ser muy VARIADA y CREATIVA, y no se debe parecer a las anteriores!"})

                    game_response = client.chat.completions.create(
                        model="gpt-4o-mini",
                        messages=game_messages_for_api,
                        temperature=0.8,
                        max_tokens=300
                    )
                    raw_reg_question_text = game_response.choices[0].message.content
                    question, options, correct_answer_key = parse_reg_question_response(raw_reg_question_text)

                    if question:
                        st.session_state.reg_current_question = question
                        st.session_state.reg_current_options = options
                        st.session_state.reg_correct_answer = correct_answer_key

                        display_question_text = f"**Nivel {int(st.session_state.reg_correct_streak / 3) + 1} - Aciertos consecutivos: {st.session_state.reg_correct_streak}**\n\n**Pregunta de L√≠neo:** {question}\n\n"
                        for key in sorted(options.keys()):
                            display_question_text += f"{key}) {options[key]}\n"

                        st.session_state.reg_game_messages.append({"role": "assistant", "content": display_question_text})
                        st.session_state.reg_game_needs_new_question = False
                        st.rerun()
                    else:
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": "¬°Lo siento! L√≠neo no pudo preparar la pregunta en el formato correcto. ¬øPuedes pulsar 'VAMOS A JUGAR' de nuevo?"})
                        st.session_state.reg_game_active = False
                        st.rerun()

                except Exception as e:
                    st.error(f"¬°Oops! L√≠neo no pudo hacer la pregunta. Error: {e}")
                    st.session_state.reg_game_messages.append({"role": "assistant", "content": "¬°Lo siento! L√≠neo tiene un peque√±o problema para hacer preguntas ahora. ¬øPuedes intentarlo de nuevo?"})
                    st.session_state.reg_game_active = False
                    st.rerun()


        if st.session_state.reg_current_question is not None and not st.session_state.reg_awaiting_next_game_decision:
            # Audio de la pregunta
            if st.session_state.get('last_played_question_lineo') != st.session_state.reg_current_question:
                try:
                    tts_text = f"Nivel {int(st.session_state.reg_correct_streak / 3) + 1}. Aciertos consecutivos: {st.session_state.reg_correct_streak}. Pregunta de L√≠neo: {st.session_state.reg_current_question}. Opci√≥n A: {st.session_state.reg_current_options.get('A', '')}. Opci√≥n B: {st.session_state.reg_current_options.get('B', '')}. Opci√≥n C: {st.session_state.reg_current_options.get('C', '')}."
                    tts = gTTS(text=tts_text, lang='es', slow=False)
                    audio_fp = io.BytesIO()
                    tts.write_to_fp(audio_fp)
                    audio_fp.seek(0)
                    st.audio(audio_fp, format="audio/mp3", start_time=0, autoplay=True)
                    st.session_state.last_played_question_lineo = st.session_state.reg_current_question
                except Exception as e:
                    st.error(f"Error al generar o reproducir el audio de la pregunta: {e}")


            with st.form("lineo_game_form", clear_on_submit=True):
                radio_placeholder = st.empty()
                with radio_placeholder.container():
                    st.markdown("Elige tu respuesta:")
                    user_choice = st.radio(
                        "Elige tu respuesta:",
                        options=list(st.session_state.reg_current_options.keys()),
                        format_func=lambda x: f"{x}) {st.session_state.reg_current_options[x]}",
                        key="reg_answer_radio_buttons",
                        label_visibility="collapsed"
                    )

                submit_button = st.form_submit_button("Enviar Respuesta")

            if submit_button:
                st.session_state.reg_game_messages.append({"role": "user", "content": f"MI RESPUESTA: {user_choice}) {st.session_state.reg_current_options[user_choice]}"})
                prev_streak = st.session_state.reg_correct_streak

                # L√≥gica para actualizar el contador de respuestas correctas
                if user_choice == st.session_state.reg_correct_answer:
                    st.session_state.reg_correct_streak += 1
                else:
                    st.session_state.reg_correct_streak = 0 # Resetear si falla

                radio_placeholder.empty()

                # --- L√≥gica de subida de nivel y confeti ---
                if st.session_state.reg_correct_streak > 0 and \
                   st.session_state.reg_correct_streak % 3 == 0 and \
                   st.session_state.reg_correct_streak > prev_streak:
                    
                    if st.session_state.reg_correct_streak < 9: # Niveles B√°sico, Medio, Avanzado
                        current_level_text = ""
                        if st.session_state.reg_correct_streak == 3:
                            current_level_text = "Medio (como un adolescente que ya sabe algo sobre el tema del colegio)"
                        elif st.session_state.reg_correct_streak == 6:
                            current_level_text = "Avanzado (como un trabajador de Data Science senior)"
                        
                        level_up_message = f"üéâ ¬°Incre√≠ble! ¬°Has respondido {st.session_state.reg_correct_streak} preguntas seguidas correctamente! ¬°Felicidades! Has subido al **Nivel {current_level_text}** de Regresi√≥n Lineal. ¬°Las preguntas ser√°n un poco m√°s desafiantes ahora! ¬°Eres un/a verdadero/a predictor/a de l√≠neas! üöÄ"
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": level_up_message})
                        st.balloons()
                        # Generar audio para el mensaje de subida de nivel
                        try:
                            tts_level_up = gTTS(text=level_up_message, lang='es', slow=False)
                            audio_fp_level_up = io.BytesIO()
                            tts_level_up.write_to_fp(audio_fp_level_up)
                            audio_fp_level_up.seek(0)
                            st.audio(audio_fp_level_up, format="audio/mp3", start_time=0, autoplay=True)
                            time.sleep(2)
                        except Exception as e:
                            st.warning(f"No se pudo reproducir el audio de subida de nivel: {e}")
                    elif st.session_state.reg_correct_streak >= 9: # Nivel Campe√≥n o superior
                        medals_earned = (st.session_state.reg_correct_streak - 6) // 3 
                        medal_message = f"üèÖ ¬°FELICITACIONES, MAESTRO DE L√çNEAS! ¬°Has ganado tu {medals_earned}¬™ Medalla de Regresi√≥n Lineal! ¬°Tu conocimiento es asombroso y digno de un verdadero EXPERTO en Regresi√≥n Lineal! ¬°Sigue as√≠! üåü"
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": medal_message})
                        st.balloons()
                        st.snow()
                        try:
                            tts_medal = gTTS(text=medal_message, lang='es', slow=False)
                            audio_fp_medal = io.BytesIO()
                            tts_medal.write_to_fp(audio_fp_medal)
                            audio_fp_medal.seek(0)
                            st.audio(audio_fp_medal, format="audio/mp3", start_time=0, autoplay=True)
                            time.sleep(3)
                        except Exception as e:
                            st.warning(f"No se pudo reproducir el audio de medalla: {e}")
                        
                        if prev_streak < 9:
                            level_up_message_champion = f"¬°Has desbloqueado el **Nivel Campe√≥n (Maestro de Regresi√≥n Lineal)**! ¬°Las preguntas ahora son solo para los verdaderos genios y futuros cient√≠ficos de datos que dibujan el futuro con sus l√≠neas! ¬°Adelante!"
                            st.session_state.reg_game_messages.append({"role": "assistant", "content": level_up_message_champion})
                            try:
                                tts_level_up_champion = gTTS(text=level_up_message_champion, lang='es', slow=False)
                                audio_fp_level_up_champion = io.BytesIO()
                                tts_level_up_champion.write_to_fp(audio_fp_level_up_champion)
                                audio_fp_level_up_champion.seek(0)
                                st.audio(audio_fp_level_up_champion, format="audio/mp3", start_time=0, autoplay=True)
                                time.sleep(2)
                            except Exception as e:
                                st.warning(f"No se pudo reproducir el audio de campe√≥n: {e}")


                # Generar feedback de L√≠neo
                with st.spinner("L√≠neo est√° revisando tu respuesta..."):
                    try:
                        feedback_prompt = f"""
                        El usuario respondi√≥ '{user_choice}'. La pregunta era: '{st.session_state.reg_current_question}'.
                        La respuesta correcta era '{st.session_state.reg_correct_answer}'.
                        Da feedback como L√≠neo.
                        Si es CORRECTO, el mensaje es "¬°L√≠nea perfecta! ¬°Lo has entendido!" o similar.
                        Si es INCORRECTO, el mensaje es "¬°Revisa tu trazo!" o similar.
                        Luego, una explicaci√≥n sencilla para ni√±os y adolescentes.
                        Finalmente, pregunta: "¬øQuieres seguir dibujando l√≠neas de predicci√≥n?".
                        **Sigue el formato estricto de feedback que tienes en tus instrucciones de sistema.**
                        """
                        feedback_response = client.chat.completions.create(
                            model="gpt-4o-mini",
                            messages=[
                                {"role": "system", "content": reg_game_system_prompt},
                                {"role": "user", "content": feedback_prompt}
                            ],
                            temperature=0.8,
                            max_tokens=300
                        )
                        raw_lineo_feedback_text = feedback_response.choices[0].message.content

                        feedback_msg, explanation_msg, next_question_prompt = parse_reg_feedback_response(raw_lineo_feedback_text)

                        st.session_state.reg_game_messages.append({"role": "assistant", "content": feedback_msg})
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": explanation_msg})
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": next_question_prompt})

                        try:
                            tts = gTTS(text=f"{feedback_msg}. {explanation_msg}. {next_question_prompt}", lang='es', slow=False)
                            audio_fp = io.BytesIO()
                            tts.write_to_fp(audio_fp)
                            audio_fp.seek(0)
                            st.audio(audio_fp, format="audio/mp3", start_time=0, autoplay=True)
                        except Exception as e:
                            st.warning(f"No se pudo reproducir el audio de feedback: {e}")


                        st.session_state.reg_current_question = None
                        st.session_state.reg_current_options = {}
                        st.session_state.reg_correct_answer = None
                        st.session_state.reg_game_needs_new_question = False
                        st.session_state.reg_awaiting_next_game_decision = True

                        st.rerun()

                    except Exception as e:
                        st.error(f"Ups, L√≠neo no pudo procesar tu respuesta. Error: {e}")
                        st.session_state.reg_game_messages.append({"role": "assistant", "content": "Lo siento, L√≠neo tiene un peque√±o problema t√©cnico ahora mismo. ¬°Pero me encantar√≠a ver tu respuesta!"})


        if st.session_state.reg_awaiting_next_game_decision:
            st.markdown("---")
            st.markdown("¬øQu√© quieres hacer ahora?")
            col1, col2 = st.columns(2)
            with col1:
                if st.button("üëç S√≠, quiero jugar m√°s preguntas", key="play_more_questions_reg"):
                    st.session_state.reg_game_needs_new_question = True
                    st.session_state.reg_awaiting_next_game_decision = False
                    st.session_state.reg_game_messages.append({"role": "assistant", "content": "¬°Genial! ¬°Aqu√≠ va tu siguiente desaf√≠o!"})
                    st.rerun()
            with col2:
                if st.button("üëé No, ya no quiero jugar m√°s", key="stop_playing_reg"):
                    st.session_state.reg_game_active = False
                    st.session_state.reg_awaiting_next_game_decision = False
                    st.session_state.reg_game_messages.append({"role": "assistant", "content": "¬°De acuerdo! ¬°Gracias por jugar conmigo! Espero que hayas aprendido mucho sobre la Regresi√≥n Lineal. ¬°Nos vemos pronto!"})
                    st.rerun()

else:
    st.info("Para usar la secci√≥n de preguntas de L√≠neo, necesitas configurar tu clave de API de OpenAI en `secrets.toml`.")